"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.abortBatch = exports.abortItem = exports.abortAll = void 0;

var _shared = require("@rpldy/shared");

var _consts = require("../consts");

var _batchHelpers = require("./batchHelpers");

var _processFinishedRequest = _interopRequireDefault(require("./processFinishedRequest"));

var _ITEM_STATE_ABORTS;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var getIsAbortableBatch = function (batch) {
  return batch.state !== _shared.BATCH_STATES.CANCELLED && batch.state !== _shared.BATCH_STATES.FINISHED;
};

var abortNonUploadingItem = function (queue, item, next, batchAbort) {
  _shared.logger.debugLog("uploader.queue: aborting ".concat(item.state, " item  - "), item); //manually finish request for item that hasnt reached the sender yet


  (0, _processFinishedRequest["default"])(queue, [{
    id: item.id,
    info: {
      status: 0,
      state: _shared.FILE_STATES.ABORTED,
      response: "aborted"
    }
  }], next);

  if (!batchAbort) {
    (0, _batchHelpers.ensureNonUploadingBatchCleaned)(queue, item.batchId);
  }

  return true;
};

var ITEM_STATE_ABORTS = (_ITEM_STATE_ABORTS = {}, _defineProperty(_ITEM_STATE_ABORTS, _shared.FILE_STATES.UPLOADING, function (queue, item) {
  _shared.logger.debugLog("uploader.queue: aborting uploading item  - ", item);

  return queue.getState().aborts[item.id]();
}), _defineProperty(_ITEM_STATE_ABORTS, _shared.FILE_STATES.ADDED, abortNonUploadingItem), _defineProperty(_ITEM_STATE_ABORTS, _shared.FILE_STATES.PENDING, abortNonUploadingItem), _ITEM_STATE_ABORTS);

var callAbortOnItem = function (queue, id, next) {
  var batchAbort = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var state = queue.getState(),
      item = state.items[id],
      itemState = item === null || item === void 0 ? void 0 : item.state;
  return ITEM_STATE_ABORTS[itemState] ? ITEM_STATE_ABORTS[itemState](queue, item, next, batchAbort) : false;
};

var abortAll = function (queue, next) {
  var items = queue.getState().items;
  Object.keys(items).forEach(function (id) {
    return callAbortOnItem(queue, id, next);
  });
  queue.trigger(_consts.UPLOADER_EVENTS.ALL_ABORT);
};

exports.abortAll = abortAll;

var abortItem = function (queue, id, next) {
  return callAbortOnItem(queue, id, next);
};

exports.abortItem = abortItem;

var abortBatch = function (queue, id, next) {
  var state = queue.getState(),
      batchData = state.batches[id],
      batch = batchData === null || batchData === void 0 ? void 0 : batchData.batch;

  if (batch && getIsAbortableBatch(batch)) {
    batch.items.forEach(function (bi) {
      return callAbortOnItem(queue, bi.id, next, true);
    });
    queue.updateState(function (state) {
      (0, _batchHelpers.getBatchFromState)(state, id).state = _shared.BATCH_STATES.ABORTED;
    });
    (0, _batchHelpers.triggerUploaderBatchEvent)(queue, id, _consts.UPLOADER_EVENTS.BATCH_ABORT);
    (0, _batchHelpers.ensureNonUploadingBatchCleaned)(queue, batch.id);
  }
};

exports.abortBatch = abortBatch;